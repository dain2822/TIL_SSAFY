
## 250924

### [Objectives_ 학습 목표]

- ORM의 개념과 데이터 베이스 - 파이썬 간 역할을 설명할 수 있음
- QuerySet API 기본 구조를 이해하고, CRUD 전 과정을 파이썬 코드로 수행할 수 있음
- Field lookup 구문으로 원하는 조건의 데이터를 효과적으로 필터링할 수 있음
- Django Shell에서 모델 인스턴스를 만들고 save()로 저장해 객체 → 레코드 변환 흐름을 실습할 수 있음
- View 함수에서 QuerySet을 가져와 템플릿에 전달하는 Model → View → Template 데이터 흐름을 구현할 수 있음

---

### [Build_ 이론]

### ORM_ Object Relational Mapping

: 객체 지향 프로그래밍 언어의 객체(Object)와 데이터 베이스의 데이터를 매핑(Mapping)하는 기술

→ 개발자 친화적인 데이터베이스 인터페이스

- Django와 데이터 베이스 간의 언어 차이로 인한 소통 불가
    
    : Django는 Python 언어를 사용하지만 데이터베이스는 SQL 언어를 사용함
    
    ![image.png](attachment:f3b986df-a021-44b9-a073-006608b187e9:image.png)
    
- ORM의 역할 : 번역자 역할
    
    : ORM은 Django와 데이터 베이스 사이에서 언어 번역자 역할을 수행함
    
    ![image.png](attachment:03bb4fee-4c2f-487b-847e-6b6dbb9fd074:image.png)
    
    → 외국인과 대화할 때 ‘통역사’가 중간에서 언어를 번역해주는 것과 같음
    
    → 덕분에 개발자는 데이터 베이스 구조를 잘 몰라도 파이썬 코드로 쉽게 데이터를 다룰 수 있음
    
    → 코드 작성 시간을 줄이고, 실수를 줄이는 데 큰 도움을 줌
    
- Django의 데이터 상호 작용 : ORM이 일하는 방법
    - ORM은 Django 개발자를 위해 ‘QuerySet API’라는 특별한 도구를 제공함
        
        → QuerySet API는 ORM의 기능을 개발자가 Python 코드 안에서 객체 지향적이고 직관적인 방식으로 데이터 베이스를 조작할 수 있도록 제공하는 인터페이스
        

---

### QuerySet API

: 데이터 베이스의 복잡한 SQL 쿼리문을 직관적인 Python 코드로 다룰 수 있게 해주는 강력한 번역기

→ 개발자는 SQL을 직접 작성하지 않고도 .filter(), .exclude(), .order_by() 등 파이썬다운 메서드를 사용하여 원하는 데이터를 손쉽게 생성, 조회, 수정, 삭제할 수 있음

→ 코드의 가독성을 높이고 개발 생산성을 극대화하는 Django ORM의 핵심 기능임

**QuerySet API와 ORM의 동작 방식**

1. Django → DB : Django(QuerySet API)에서 ORM을 통해 데이터 베이스로 정보를 요청할 때
    
    : SQL 쿼리로 변환되어 데이터 베이스로 전달됨
    
2. DB → Django : 데이터 베이스가 요청에 대한 응답을 보낼 때
    
    : ORM은 SQL이 결과를 다시 파이썬이 이해할 수 있는 Pyhton Object
    
    : QuerySet 또는 Instance 형태로 변환하여 Django로 변환
    
    ![image.png](attachment:4180415a-8ebb-4e4e-aff4-27078f2e445e:image.png)
    

**QuerySet API 구문 기본 구조**

![image.png](attachment:a431e8f6-2dea-4ad0-bc5c-246a623601ec:image.png)

- Article (모델 클래스)
    - 역할 : 데이터 베이스 테이블에 대한 Python 클래스 표현
    - articles_article 테이블의 스키마(필드, 데이터 타입 등)를 정의하며, Django ORM이 데이터 베이스와 상호작용할 때 사용하는 기본적인 구조체
- .objects (매니저, manager)
    - 역할 : 데이터 베이스 조회(Query) 작업을 위한 기본 인터페이스
    - 모델 클래스가 데이터 베이스 쿼리 작업을 수행할 수 있도록 하는 진입점
    - Django는 모든 모델에 objects라는 이름의 매니저를 자동으로 추가하여, 이 매니저를 통해 .all(), .filter() 등의 쿼리 메서드를 호출
- .all() (QuerySet API 메서드)
    - 역할 : 특정 데이터 베이스 작업을 수행하는 명령
    - 매니저를 통해 호출되는 메서드로, 해당 모델과 연결된 테이블의 모든 레코드(rows)를 조회하려는 SQL 쿼리를 생성하고 실행

![QuerySet API와 ORM의 동작 방식 예시](attachment:b0d166df-8f92-4bdb-bcf4-3a2044836abd:image.png)

QuerySet API와 ORM의 동작 방식 예시

**Query란?**

- 데이터 베이스에 특정한 데이터를 보여달라는 요청,
- “쿼리문을 작성한다.”
    
    ⇒ “원하는 데이터를 얻기 위해 데이터 베이스에 요청을 보낼 코드를 작성한다.”
    
- Django에서 Query가 처리되는 과정 정리
    1. 파이썬 코드 → ORM : 개발자의 QuerySet API(파이썬 코드)가 ORM으로 전달
    2. ORM → SQL 변환 : ORM이 이를 데이터 베이스용 SQL 쿼리로 변환하여 데이터 베이스에 전달
    3. DB 응답 → ORM : 데이터 베이스가 SQL 쿼리를 처리하고 결과 데이터를 ORM에 반환
    4. ORM → QuerySet 변환 : ORM이 데이터 베이스의 결과를 QuerySet(파이썬 객체) 형태로 변환하여 우리에게 전달

**QuerySet이란?**

- 데이터 베이스에서 전달받은 객체 목록(데이터 모음)
- 순회 가능한 데이터로 1개 이상 데이터를 불러와 사용 가능함
- Django ORM을 통해 만들어진 자료형
- 데이터 베이스가 단일 객체를 반환할 때는 QuerySet이 아닌 모델(Class)의 인스턴스로 반환됨

### QuerySet API 실습

**CRUD**

: 대부분의 소프트웨어가 가지는 기본적인 데이터 처리 기능인 생성, 조회, 수정, 삭제를 묶어 이르는 말

→ Django에서는 QuerySet API를 통해 복잡한 SQL문 없이 Python 코드로 이러한 CRUD 작업을 직관적으로 수행할 수 있음

- Create : 새로운 데이터를 생성(저장)
- Read : 기존 데이터를 조회
- Update : 기존 데이터를 수정(갱신)
- Delete : 기존 데이터를 삭제

**QuerySet API 실습 사전 준비**

- 외부 라이브러리 설치 및 의존성 기록
    - IPython은 일반 파이썬 셸(명령창)보다 자동 완성 등 편리한 파이썬 작업 환경을 만들어주는 도구
        
        `$ pip install ipython`
        
        `$ pip freeze > requirements.txt`
        
- Django Shell 접속하기 : Django Shell이란?
    - Django 프로젝트의 코드를 명령창에서 바로 실행하고 테스트하는 특별한 파이썬 환경
    - Django 환경 내에서 실행되기 때문에 입력하는 QuerySet API 구문이 Django 프로젝트에 영향을 미침
- Django Shell 접속하기
    
    `$ python [manage.py](http://manage.py) shell`
    
    ![image.png](attachment:f92fafd2-51fb-4e81-bc94-216a7f2999e7:image.png)
    
- Shell “-v” 옵션 (기본값 : 1)
    - 출력 상세도(verbosity level) 설정 : 일반적인 정보 외에 더 많은 디버깅 정보나 진행 상황 메시지를 보여달라는 요청
    - shell 시작  시 Django 프로젝트에 등록된 model이 자동으로 import된 내용이 출력된 것
        
        `$ python [manage.py](http://manage.py) shell -v 2`
        
        ![image.png](attachment:3db58176-410d-4001-8296-6fdd90901da2:image.png)
        

**Create**

- 데이터 객체를 만드는(생성하는) 3가지 방법
    1. 빈 객체 생성 후 값 할당 및 저장
        
        ![image.png](attachment:b36648ff-8cf3-4825-a7cb-c35b58d34d67:image.png)
        
        ![image.png](attachment:ffd4de04-8e6d-402b-a022-2013d518fa36:image.png)
        
        ![image.png](attachment:27c9aae2-9cdc-4656-ba12-6477208d8389:image.png)
        
        ![image.png](attachment:b071bdf6-8efe-4bbd-b961-0a773c81fd81:image.png)
        
    2. 초기 값과 함께 객체 생성 및 저장
        
        ![image.png](attachment:ad1465fd-6901-4ae2-8c0f-b3dcdf77ccf8:image.png)
        
        : 첫 번째 방법, 두 번재 방법 모두 결국 save 메서드를 호출해야 비로소 DB에 데이터가 저장됨
        
        : 테이블에 한 행(레코드)이 쓰여진 것
        
        - save() 메서드
            
            : 객체를 데이터 베이스에 저장하는 인스턴스 메서드
            
            → 객체를 먼저 생성한 후, 데이터 베이스에 저장하기 전에 추가적인 처리(ex: 다른 데이터와 관계 설정, 유효성 검사)가 필요할 때 save()를 호출함
            
    3. create() 메서드로 한 번에 생성 및 저장
        
        ![image.png](attachment:5864eb90-bfc1-44b3-b2fe-cd8cba7d62e2:image.png)
        
        → save()를 명시적으로 호출하지 않는 것처럼 보이는 이유는 create() 메서드 자체가 객체 생성과 데이터 베이스 저장을 한 번에 처리하는 단축 메서드이기 때문임
        

**Read**

- 대표적인 조회 메서드
    - QuerySet을 반환하는 메서드
        - all() : 전체 데이터 조회
            
            ![image.png](attachment:096b39e9-7c81-4623-bf28-6f1ad513ebc9:image.png)
            
        - filter() : 주어진 매개변수와 일치하는 객체를 포함하는 QuerySet 반환
            
            ![image.png](attachment:5f8f187f-abe9-4227-8fb3-e1baf495c3cc:image.png)
            
    - QuerySet 을 반환하지 않는 메서드
        - get() : 주어진 매개변수와 일치하는 객체를 반환
            
            ![image.png](attachment:f66f6b93-5e4d-4498-8fc3-befaf343a824:image.png)
            
        
        - get()의 특징
            - 객체를 찾을 수 없으면 DoesNotExist 예외를 발생시키고, 둘 이상의 객체를 찾으면 MultipleObjectsReturned 예외를 발생시킴
            - primary key와 같이 고유성(uniqueness)을 보장하는 조회에서 사용해야 함
            
            ![image.png](attachment:efcdaf57-cb4c-45b5-97fd-ee72af388096:image.png)
            

**Update**

- 데이터 수정 방법
    
    : 인스턴스 변수를 변경 후 save 메서드 호출
    
    ![image.png](attachment:c99b8f1b-60f9-4cb7-a0ad-b569d721a6c8:image.png)
    

**Delete**

- 데이터 삭제 방법
    
    : 삭제하려는 데이터 조회 후 delete 메서드 호출
    
    ![image.png](attachment:b171f0b6-9846-46d3-9e22-057a237ebc0a:image.png)
    

---

### ORM with view_ 전체 게시글 조회

- View 함수에서 QuerySet API 활용하기
    - View에서의 QuerySet API
        
        : 웹 페이지에 보여줄 데이터를 DB에서 가져올 때 사용
        
        : 사용자가 입력한 새로운 데이터를 DB에 저장할 때 사용
        
        ![image.png](attachment:22474409-cc68-475d-a09f-4cce2f163437:image.png)
        
- 2가지 Read(조회)
    1. 전체 게시글 조회✅
        - 최종 결과 화면 미리보기
            
            ![image.png](attachment:a2062bdf-088b-421e-b25a-899ff600b350:image.png)
            
        - 요청 정의
            
            ![image.png](attachment:649eb8f9-7ed7-44ae-b919-cc0597d3a0c6:image.png)
            
            ![image.png](attachment:b143f002-e30e-48fb-8dbb-fdd17bbae96e:image.png)
            
            - crud는 Django 프로젝트 이름
            - 앱 URL에서 빈 문자열(’’)의 의미
                
                → 프로젝트 urls.py에서 inclued(”articles.urls”)는 articles/로 시작하는 모든 요청을 articles 앱의 urls.py로 넘겨줌
                
                → articles/ 부분은 잘려나가고 나머지 URL만 앱의 urls.py로 전달됨
                
                ⇒ path(’’, views.index)는 articles/ 바로 뒤에 아무 것도 없는 경우(articles/ 자체)를 의미하고 해당 view함수를 실행하게 됨
                
        
        ![image.png](attachment:a6469f2e-e079-44aa-9fd5-9bf94725657e:image.png)
        
    2. 단일 게시글 조회

---